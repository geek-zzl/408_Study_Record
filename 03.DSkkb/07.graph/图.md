# 图

图是由点和边组成的集合，边记录的是结点之间的关系

## 基本术语

1. 结点, 边(弧)
2. 有向边, 无向边, 有向图, 无向图, 完全图, 子图
    完全图(从任意点到任意点都有边)
3. 度, 入度, 出度
    有向图(度) = 入度 + 出度
4. 路径, 回路
    回路 -> 有向图 才有意义
5. 连通图, 强连通图, 连通分量, 强连通分量
    连通图(无向图) 从任意点到任一点都有路径
    有一个无向连通图, 有n个点, 则 最少有n-1个边
    强连通图 (有向图)
    有向强连通图, 有n个点, 则最少有 n 条边
    连通分量 : 针对 无向图 极大连通子图
    强连通分量 : 针对 有向图 极大连通子图
6. 权值, 带权图(网)

## 图的存储

### 邻接矩阵(无向图)

```C++
#define MaxCnt 50 // 节点最大数量
struct Graph {
    EleType Vex[MaxCnt];
    int arr[MaxCnt][MaxCnt];
    int vexnum, edgnum;
};
```
邻接矩阵是一个多维数组, 存储节点间边的关系

优点:
简单直观
快速判断AB两点间是否有边 `if(arr[A][B])`
缺点:
浪费空间
不能快速访问与某点有关联的边

### 邻接表 -> 链表
```C++
#define struct 
```
n个点 n条链表
优点: 节省空间 快速访问与某点有关的边
缺点: 不直观 不能快速判断AB之间的关系

## 图的遍历

### DFS 递归实现

### BFS 广度优先遍历 -> 队列实现
从起点开始先便利所有的相同的点 队列
BFS DFS

## 图的应用

### 最小生成树 MST

对于一个图来说, 删掉一些边, 使得每两个节点之间只有一条路径
那么, 删掉边以后, 可以得到一棵树, 这棵树就叫做该图的生成树
所有生成树中, 所有边权相加后, 总权值最小的生成树, 叫做最小生成树

性质: 
1. N 点 、N - 1 条 边
2. 最小生成树的权值总和 唯一 , 但最小生成树不一定唯一

#### 最小生成树的求解方法

##### Prim算法 以点为基准 
普利姆算法 
不断地联通一些点

加入一个点 多一条内部边 
多一些外部边 少一些内部边 

1. 选择起点
2. 从所有外部联通的边中, 选择一条权值最短的
3. 将这条边所连接的点加入内部
4. 加入后, 多了一些外部边, 少了一些内部边
5. 继续这个过程, 知道所有点均已连通

##### Kruskal 算法 以边为基准
前置知识: 
并查集 树形结构(森林) 
记录每一个节点的父节点(森林)
合并(合并两个集合) 查询(查询两个点是否属于同一集合)

**以边为基础**

1. 初始化并查集, 将所有边按照权值排序
2. 按照权值从小到大, 依次遍历所有边
3. 遍历一条边时, 判断这条边的两个端点是否相连(并查集)
4. 若相连, 则这条边不是最小生成树中的一条边
5. 若不相连, 则这条边是最小生成树中的一条边, 连通这两点
6. 继续这个过程, 知道所有点均已连通 

求最小生成树权值 : 建议使用kruskal算法 比 prim 算法 口算 简单一些


### 最短路径

最短路径可能不唯一
但 最短权值唯一
从A到B的最短路径
#### Dijkstra 单源最短路
一个源点(起点)
求A到各个点的最短路径分别是多少
求**单源**最短路径
不能有负权边

负权边 负环 没有最短路 X

1. 将所有点的答案改为INF, 确定起点, 更新起点的答案为0. 
2. 在所有有答案且答案未确定的点中, 选择答案最小的
3. 将该点的答案确定
4. 遍历以该点为起点的所有边, 更新边终点的答案
5. 继续这个过程, 直道所有点的答案均已确定

tips ： 
图 点和边 
地图 ？ 不适用 太慢了 断网了 如何算 算不了 在线型算法
dijkstra 离线算法

#### Floyd 多源最短路

多源最短路径
可以求任一点到任一点的最短路径
四行
```C++
ans[x][y] // 从x到y点的最短路径
// 邻接矩阵存图
// 通过中转点更新最短路径
for (int i = 1; i <= n; i ++) // i 表示中转点
    for (int j = 1; j <= n; j ++) // j 表示 起点
        for (int k = 1; k <= n; k ++) // k 表示终点
            ans[j][k]  = min (ans[j][k] , ans[j][i] + ans[i][k]);
```

> cite from : https://blog.csdn.net/RunningBeef/article/details/114683747
> i 循环 中间点的循环要在最外层
> 因为floyd本质目的是对于每个点对i-j的距离可以被其它点优化，而且可以被多个点共同优化，如果循环k在内层，那么i,j每次只能得到一个点的优化。

优点 : 
    多源最短路 任一点
    简单 代码实现容易
缺点 :
    慢 时间复杂度O(n^3) 暴力算法 时间突破天际


<!-- ### 有向无环图描述表达式  -->

### AOV 网

类比于 同步
用有向图表示一个工程, 其结点表示活动
有向边 1 -> 5 表示 1 活动必须先于5活动这种关系
则称这个图为AOV网 (顶点表示活动的网络)
作用 : 用于拓扑排序

### 拓扑排序

与排序没什么关系
对于AOV网来说, 找到所有活动的一种排序
使得按照排序序列进行活动时, 不违反网中的活动先后顺序
在求解过程中通常使用入度计数来实现

就是一个规划问题
1. 求做事情的顺序

2. 判断是否有环 如果某一时刻没有任何一个点入度为0, 且还有点未被选出来

### 关键路径
AOE网及其关键路径
AOE 边表示活动的网络
用又向图表示一个工程, 其边表示活动
有向边 1 -> 5 的权值3表示活动的开销 (通常为活动所需)
则称这个图为AOE网 (边表示活动的网络)

关键路径 ： 从源点到汇点的最长路径
    总工期
    边 ： 活动
    点 ： 状态

每个任务的最早、 最晚开始时间
E 5 9
C 2 7
最早 拓扑排序 算
最晚 逆拓扑排序 算

关键路径 源 2 3 5
    5 + 10 + 11
    5 + 4 + 6 + 11
    A 9 9  
    B 5 12