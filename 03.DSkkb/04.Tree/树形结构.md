# 树形结构

## 树

### 数据结构中的树

### 节点定义
```C++
struct Node {
    EleType data;
    Node *child[];
};
```

### 基本术语

1. 父节点、子节点、兄弟节点、祖先、子孙
2. 节点的度(子结点的个数)、树的度(最大的节点的度)
3. 叶子节点(终端结点)与分支节点(非终端结点)
 度为0的结点 不为0的点

4. 结点的深度、高度和层次
5. 路径与路径长度

树的结点数 = 度不为0的点延伸出的点 + 根结点 = 所有度的点数之和


度为0 + 度为1 + 度为2 + 度为3 + ... = n

树中结点数 = 
1. 度不为0的点延伸出的点数 + 根节点
2. 所有度的结点数量之和

121 
5 10、4 5、3 0、2 10、1 30
树种叶子结点个数 = 121-55 = 66

## 森林

树的集合称为森林

## 二叉树

```C++
struct Node {
    EleType data;
    Node *left_child, *right_child;
};
```

### 二叉树的基本术语

1. 左孩子(左子树)、右孩子(右子树)

2. 每层的结点个数
1 2 4 8 16 32 满二叉树 $2^n - 1(n为树的高度)$ 第n层 $2^(n-1)$个点

3. 满二叉树(满)、完全二叉树(符合)

4. 使用一维数组存储二叉树

|root|lchild|rchild |
|----|------|-------|
|1   |$2*n$ |$2*n+1$|

5. 广义表

可以用来表示树 也可以用来表示其他
7(2(3),1(4(,8),9))
1(2(3(6,7),4(7,8)),3(4(8,9),5(9,10)))

### 二叉树的遍历
#### 递归
 先序 7645213
 中序 4672153
 后续 4612357
tips : 快速输出**后续**遍历
^\ ^\ ^\ ^\ ^\ 欻欻欻 刷刷刷
#### 队列
 层序 7 6 5 4 2 3 1
根据遍历还原二叉树

----

# 树形结构 (下)

## 随机生成树

随机数 srand
```C++
#include <stdlib.h>
#include <time.h>

rand(); // 获得一个随机数
srand(x); // 以x初始化随机种子
srand(time(0));

```

根据遍历还原二叉树

先序 C D U T R N E P
中序 T U D N R E C P

### 二叉树 线索化

借用树中结点内的空指针, 保存前驱及后继的信息线索化二叉树结点与普通二叉树结点在结构上略有不同

```C++
struct node {

};
```

线索化二叉树的关键: 左前驱、右后继
因为二叉树只有左右指针，无法向上查找，线索就可以向上

### 树与二叉树的转化
左孩子 右兄弟
左挂孩子 右挂兄弟
孩子 兄弟 表示法

### 森林与二叉树的转换

各 树 的 根节点 为兄弟

树的遍历 : 先序遍历、后序遍历、层序遍历

树的遍历 二叉树的遍历
先先一样
后中一样

森林 先 -> 树 先
    中 -> 树 后

### 二叉排序树 (二叉查找树、二叉搜索树、BST树)

二叉排序树:
    如果一棵二叉树中的任意结点均满足
    它左子树上所有的节点值都小于自身
    它右子树上所有的节点值都大于自身
    
插入元素 : 
    类似二分查找

删除元素:
    从树根出发, 进行查找, 找到对应元素
    是叶子节点 直接删除
    不是叶子节点:
        口令：左子树的右右右 右子树的左左左

### 哈夫曼树

最小带权路径

哈夫曼编码

树形结构
树 森林
二叉树 特殊
二叉树的遍历
还原树
树<==>二叉树 森林 <==> 二叉树
树 : 先后层 森林 : 先中
BST : 插入 删除 (二叉排序树 查找树)
Haffman Tree 哈夫曼树