# 排序

十大排序算法
9个内部排序算法 
## 基本概念
进行一系列操作使得序列有序

## 排序算法性能指标:
> 1. 时间复杂度 最好 最坏 平均
> 
> 2. 空间复杂度 (额外)
> 
> 3. 稳定性

没有最好 只有最适用的


## 插入类排序
1 2 3
### 直接插入排序

将待排序区的第一个元素通过大小比较
直接插入到已排序区的指定位置
使得已排序元素数量加一
不断重复此过程，直到所有元素均已排序

* 第一个元素默认在已排序区
* 只进行两两交换
> 1. 时间复杂度 
>   最好 : O(n) 最坏 : O(n^2) 
>   平均 : O(n^2)
> 2. 空间复杂度 (额外)
>   O(1)
> 3. 稳定性 稳定

### 折半插入排序

与直接插入排序类似
只是在寻找元素插入位置时
改用折半查找法进行查找

效率上: 和直接插入排序 没区别
唯一区别: 元素的比较次数上有区别 不需要顺次比较

### 希尔排序

* 分组的直接插入排序

根据不同的增量, 将数据分组
对于每组数据, 分别进行直接插入排序
然后缩小增量, 重复这个过程
最终当增量为1时，相当于进行了直接插入排序
这轮排序后，数据整体有序


时间 O(n^1.xxx) 不确定
空间 O(1)
稳定 不稳定 分组跨范围

## 交换排序
两两比较相邻的元素
如果不满足大小关系 就交换他们
遍历一轮序列后  最值元素会被交换到最后
重复上述过程 直到所有元素均有序

若某论遍历没有触发任何交换
则此时序列已经有序, 可以提前结束排序

4 5 
### 冒泡排序(起泡排序、泡排序)

两两比较相邻的元素
如果不满足大小关系，就交换它们
遍历一轮序列后，最值元素就会被交换到最后
重复上述过程，直到所有元素均有序
若某一轮遍历没有触发任何交换
则此时序列已经有序，可以提前结束排

稳定排序
两两比较 符合条件交换

### 快速排序

时间复杂度
    最好 O(nlogn) 最坏 O(n^2) 平均O(nlogn)
空间 O(1) 平均层深 O(logn)~O(n)
稳定性 不稳定

## 选择排序
6 7
### 简单选择排序

找到最小的 放到最前面
整体比较 找到最小的 放到 最前

O(n^2)

### 堆排序

#### 优先队列/堆

一维数组 去模拟的完全二叉树

堆/优先队列是一种数据结构 
这里讲解的堆为二叉堆

##### 堆的性质
大顶堆中的最大元素在堆顶元素(树根)处
小顶堆同理
左子树 与 右子树 的值 小于 等于 自身

##### 堆的操作
* 插入操作 自下向上 调整 O(logN)
    > 将新插入的元素放在后面第一个空位处
    > 
    > 从插入的元素开始, 向上进行比较
    > 
    > 若下面的元素比上面大, 除法交换, 向上进行比较

* 删除操作 自下向上 调整 O(logN)
    > 将堆顶元素与最后一个元素交换后, 将其删除

    只能删除堆顶元素
* 获得堆顶元素

* 堆化操作
 给定一初始化序列(数组), 将其调整为

#### 堆排序
0. 注意:
1. 将序列堆化
2. 不断删除堆顶元素 并调整(没有真正删除) (堆顶元素放到最后 n - 1 调整堆(不断down))
3. 将所有元素删除后序列有序 

## 归并排序 和 基数排序

### 归并排序
将待排序区间分为左区间和右区间
对两个区间分别进行归并排序
在两个区间有序后
时间 O(nlogn)
空间 logn + n = O(n)
稳定 稳定

### 计数排序
统计出现的次数
O(n)
O(max(num[i]))
吉祥物 .

### 基数排序
将待排序序列组织进不同的桶当中
在按照桶的顺序将元素拿出
经过k轮操作后
序列整体有序

时间 O(kn)
空间 O(r) O(x) O(x + n)
稳定 稳定


## 外部排序 多路归并排序